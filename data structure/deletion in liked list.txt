//deleting a node in linked list
/*IETRATIVE METHOD(STEPS TO FOLLOW TO DELETE NODE AS FOLLOW)
1)FIND THE PREVIOUS NODE OF THE NODE TO BE  DELETED
2)CHANGE THE NEXT OF PREVIOUS NODE
3)FREE MEMORY FOR THE NODE TO BE DELETED;
*/
#include<stdio.h>
#include<stdlib.h>
//A LINKED LIST NODE
struct node{
int data;
struct node*next;
};
void deletenode(struct node**head,int key)
{
    //store head node
    struct node*temp=*head,*prev;
    //if head node itself holds the key t be deleted
    if(temp!=NULL && temp->data==key)
    {
        *head=temp->next;//changed head
        free(temp);//free old head
        return;
    }
    //search for the key to be deleted keep the track of the previous node  as we need to change 'prev->next'
    while(temp!=NULL && temp->data!=key)
    {
        prev=temp;
        temp=temp->next;

    }
    //if key was not present in the linked list
    if(temp==NULL)
        return;
    //unlink the node from linked list
    prev->next=temp->next;
    free(temp);

}


//TO SHOW THE LIST
void printlist(struct node*n)
{
    while(n!=NULL)
    {
        printf(" %d-->",n->data);
        n=n->next;
    }
}
//driver code
int main(){
    //creating a node
   struct node*head=NULL;
   struct node*second=NULL;
   struct node *third=NULL;
    //allocate memory in the heap;
    head=(struct node*)malloc(sizeof(struct node));
    second=(struct node *)malloc(sizeof(struct node));
   third=(struct node*)malloc(sizeof(struct node));
    //assigning values and linking the nodes to each other;
    head->data=1;
    head->next=second;
    second->data=2;
    second->next=third;
    third->data=4;
    third->next=NULL;
    printlist(head);
    /*output:
    1--> 2--> 4-->

  Process returned 0 (0x0)   execution time : 0.063 s
  Press any key to continue.
    */
    printf("\n");
    deletenode(&head,2);
    printlist(head);
    /*output:
    1--> 2--> 4-->
    1--> 4-->
 Process returned 0 (0x0)   execution time : 0.062 s
 Press any key to continue.

    */

}
______________________________________________________________




/*DELETE A LINKED LIST AT A GIVEN POSITION:
if the node is deleted is the root simply delete it .to delete  MIDDLE NODE we must have a
    pointer to the node previous to the node to be deleted .so if position are not zero we
    run a loop position -1 time and get a pointer to the previous node
*/
#include<stdio.h>
#include<stdlib.h>
//a linkedd list node
struct node{
   int data;
   struct node*next;
};
//given a reference (pointer to pointer)to the head of the list and an int inserts
//a new node on the front of the list.
void insert(struct node**head,int new_data)
{
    struct node*new_node=(struct node*)malloc(sizeof(struct node));//allocate memory in the heap
    new_node->data=new_data;
    new_node->next=(*head);
    (*head)=new_node;
}
//given a reference(pointer to pointer )to the head of the list
//and a position .deletes the node at given position
void deletenode(struct node**head,int position)
{
    if(*head==NULL)
    {printf("LIST IS EMPTY");
    return;}
    //store head node
    struct node*temp=*head;
    //if heads need to be removed
    if(position==0)
    {
        *head=temp->next;
        free(temp);
        return;
    }
    //find previous node of the node to be deleted
    for(int i=0;temp!=NULL && i<position-1;i++)
    {
        temp=temp->next;
    }
    //if position is more than number of nodes
    if(temp==NULL||temp->next==NULL)
    {
        return;
    }
    //node temp->next is the node to be deleted
    //store pointer to the next of node to be deleted
    struct node*next=temp->next->next;
    //unlinked the node from linked list
    free(temp->next);//free memory;
    temp->next=next;//unlink the deleted node from list

}
//the list on the screen
void printlist(struct node*n)
{
    if(n==NULL){printf("list is empty");}
    while(n!=NULL)
    {
        printf(" %d->",n->data);
        n=n->next;
    }
}
//driver code
int main(){
    struct node*head=NULL;
   insert(&head,50);
    insert(&head,40);
     insert(&head,30);
      insert(&head,20);
       insert(&head,10);
       puts("created linked list is:= ");
   printlist(head);
     deletenode(&head,1);
   puts("\nTHE NEW LINKED LIST AFTER DELETION BE:=");
 printlist(head);
}
/*output
created linked list is:=
 10-> 20-> 30-> 40-> 50->
THE NEW LINKED LIST AFTER DELETION BE:=
 10-> 30-> 40-> 50->
Process returned 0 (0x0)   execution time : 0.063 s
Press any key to continue.
*/

__________________________________________________________


/*iterate through the linked list and delete all the nodes one by one.
 the main point here is not to access the next of the current pointer if the current
 pointer is deleted.
*/
//c program to delete the ;linked list
#include<stdio.h>
#include<stdlib.h>
//create a node i the linked list
struct node{
int data;
struct node*next;
};
//function to delete the entire linked list
void deletelist(struct node**head)
{
    struct node*current = *head;
    struct node*next;
    while(current!=NULL)
    {
        next= current->next;
        free(current);
        current=next;
    }
    //dereference to affect the real head back i the caller
    *head=NULL;
}
//given a reference(pointer  to the pointer)to the head of a list and
//an int . insert a new node on the front of the list
void insert(struct node**head,int new_data)
{
    //allocate a node
    struct node*new_node=(struct node*)malloc(sizeof(struct node));
    //put in the data
    new_node->data=new_data;
    //link the old list off the new node
    new_node->next=(*head);
    //move the head to point to the new node
    (*head)=new_node;
}
//driver code
int main()
{
  //start wit the empty list;
  struct node*head=NULL;
  //use insert function to construct the linked list
  insert(&head,5);
  insert(&head,4);
  insert(&head,3);
  insert(&head,2);
  insert(&head,1);

  printf("deleting the linked list :\n");
  deletelist(&head);
  printf("\nlinked list is deleted successfully");

}
/*output:
deleting the linked list :

linked list is deleted successfully
Process returned 0 (0x0)   execution time : 0.062 s
Press any key to continue.
*/
_______________________________________________________________